## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _VARR(items):
    k = EUDVArray(len(items))()
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __ifloordiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov // v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __ifloordiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov // v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 16) function CountAtLoc(player: TrgPlayer, unit: TrgUnit, loc: TrgLocation) {
@EUDTypedFunc([TrgPlayer, TrgUnit, TrgLocation])
def CountAtLoc(player, unit, loc):
    # (Line 18) var x = 0xFF;
    x = EUDVariable()
    x << (0xFF)
    # (Line 19) foreach(i : py_range(31, -1, -1)) {
    for i in range(31, -1, -1):
        # (Line 20) if (x >= py_pow(2, i)) {
        if EUDIf()(x >= pow(2, i)):
            # (Line 21) x -= py_pow(2, i);
            x.__isub__(pow(2, i))
            # (Line 22) if (!Bring(player, AtMost, x, unit, loc)) {
            if EUDIf()(Bring(player, AtMost, x, unit, loc), neg=True):
                # (Line 23) x += py_pow(2, i);
                x.__iadd__(pow(2, i))
                # (Line 24) }
                # (Line 25) }
            EUDEndIf()
            # (Line 26) }
        EUDEndIf()
        # (Line 27) return x;

    EUDReturn(x)
    # (Line 28) }
    # (Line 30) function __LocOrderBase(

# (Line 31) epd,
# (Line 32) order_lsh8,
# (Line 33) loc: TrgLocation
# (Line 34) ) {
@EUDTypedFunc([None, None, TrgLocation])
def __LocOrderBase(epd, order_lsh8, loc):
    # (Line 35) const loc_epd = loc * 5;
    loc_epd = loc * 5
    # (Line 36) DoActions(loc_epd.AddNumber(EPD(0x58DC4C)));
    DoActions(loc_epd.AddNumber(EPD(0x58DC4C)))
    # (Line 38) const x1 = dwread_epd(loc_epd);
    x1 = f_dwread_epd(loc_epd)
    # (Line 39) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 40) const y1 = dwread_epd(loc_epd);
    y1 = f_dwread_epd(loc_epd)
    # (Line 41) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 42) const x2 = dwread_epd(loc_epd);
    x2 = f_dwread_epd(loc_epd)
    # (Line 43) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 44) const y2 = dwread_epd(loc_epd);
    y2 = f_dwread_epd(loc_epd)
    # (Line 46) const x = (x1 + x2) / 2;
    x = (x1 + x2) // 2
    # (Line 47) const y = (y1 + y2) << 15;  // = (y1 + y2) / 2 * 65536
    y = _LSH((y1 + y2),15)
    # (Line 49) epd += 0x4D / 4;
    epd.__iadd__(0x4D // 4)
    # (Line 50) SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00);
    # (Line 51) epd += (0x58 - 0x4C) / 4;
    DoActions(SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00))
    epd.__iadd__((0x58 - 0x4C) // 4)
    # (Line 52) SetMemoryEPD(epd, SetTo, y + x);
    # (Line 53) }
    DoActions(SetMemoryEPD(epd, SetTo, y + x))
    # (Line 70) function BuildProbeEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildProbeEPD(epd, loc, building):
    # (Line 71) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 72) __LocOrderBase(epd, 31 << 8, loc);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(31,8), loc)
    # (Line 73) }
    # (Line 90) function BuildProbe(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildProbe(unitPTR, loc, building):
    # (Line 91) BuildProbeEPD(EPD(unitPTR), loc, building);
    BuildProbeEPD(EPD(unitPTR), loc, building)
    # (Line 92) }
    # (Line 109) function BuildDroneEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildDroneEPD(epd, loc, building):
    # (Line 110) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 111) __LocOrderBase(epd, 25 << 8, loc);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(25,8), loc)
    # (Line 112) }
    # (Line 129) function BuildDrone(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildDrone(unitPTR, loc, building):
    # (Line 130) BuildDroneEPD(EPD(unitPTR), loc, building);
    BuildDroneEPD(EPD(unitPTR), loc, building)
    # (Line 131) }
    # (Line 148) function BuildSCVEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildSCVEPD(epd, loc, building):
    # (Line 149) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 150) __LocOrderBase(epd, 30 << 8, loc);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(30,8), loc)
    # (Line 151) }
    # (Line 168) function BuildSCV(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildSCV(unitPTR, loc, building):
    # (Line 169) BuildSCVEPD(EPD(unitPTR), loc, building);
    BuildSCVEPD(EPD(unitPTR), loc, building)
    # (Line 170) }
    # (Line 187) function COrderLocEPD(epd, order, loc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def COrderLocEPD(epd, order, loc):
    # (Line 188) __LocOrderBase(epd, order << 8, loc);
    __LocOrderBase(epd, _LSH(order,8), loc)
    # (Line 189) }
    # (Line 207) function COrderLoc(unitPTR, order, loc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def COrderLoc(unitPTR, order, loc):
    # (Line 208) __LocOrderBase(EPD(unitPTR), order << 8, loc);
    __LocOrderBase(EPD(unitPTR), _LSH(order,8), loc)
    # (Line 209) }
    # (Line 226) function COrderUnitEPD(unitEPD, order, targetPTR) {

@EUDFunc
def COrderUnitEPD(unitEPD, order, targetPTR):
    # (Line 227) bwrite_epd(unitEPD + 0x4D / 4,  1, order);
    f_bwrite_epd(unitEPD + 0x4D // 4, 1, order)
    # (Line 228) SetMemoryEPD(unitEPD + 0x5C / 4, SetTo, targetPTR);
    # (Line 229) }
    DoActions(SetMemoryEPD(unitEPD + 0x5C // 4, SetTo, targetPTR))
    # (Line 246) function COrderUnit(unitPTR, order, targetPTR) {

@EUDFunc
def COrderUnit(unitPTR, order, targetPTR):
    # (Line 247) COrderUnitEPD(EPD(unitPTR), order, targetPTR);
    COrderUnitEPD(EPD(unitPTR), order, targetPTR)
    # (Line 248) }
    # (Line 265) function RotateLocation(targetLoc: TrgLocation, originLoc: TrgLocation, angle) {

@EUDTypedFunc([TrgLocation, TrgLocation, None])
def RotateLocation(targetLoc, originLoc, angle):
    # (Line 266) const locTable = EPD(0x58DC4C);
    locTable = EPD(0x58DC4C)
    # (Line 267) const target = targetLoc * 5;
    target = targetLoc * 5
    # (Line 268) const origin = originLoc * 5;
    origin = originLoc * 5
    # (Line 269) DoActions(list(
    # (Line 270) target.AddNumber(locTable),
    # (Line 271) origin.AddNumber(locTable)
    # (Line 272) ));
    DoActions(FlattenList([target.AddNumber(locTable), origin.AddNumber(locTable)]))
    # (Line 274) const tx1 = dwread_epd(target);
    tx1 = f_dwread_epd(target)
    # (Line 275) const ox1 = dwread_epd(origin);
    ox1 = f_dwread_epd(origin)
    # (Line 276) DoActions(list(
    # (Line 277) target.AddNumber(1),
    # (Line 278) origin.AddNumber(1)
    # (Line 279) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 280) const ty1 = dwread_epd(target);
    ty1 = f_dwread_epd(target)
    # (Line 281) const oy1 = dwread_epd(origin);
    oy1 = f_dwread_epd(origin)
    # (Line 282) DoActions(list(
    # (Line 283) target.AddNumber(1),
    # (Line 284) origin.AddNumber(1)
    # (Line 285) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 286) const tx2 = dwread_epd(target);
    tx2 = f_dwread_epd(target)
    # (Line 287) const ox2 = dwread_epd(origin);
    ox2 = f_dwread_epd(origin)
    # (Line 288) DoActions(list(
    # (Line 289) target.AddNumber(1),
    # (Line 290) origin.AddNumber(1)
    # (Line 291) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 292) const ty2 = dwread_epd(target);
    ty2 = f_dwread_epd(target)
    # (Line 293) const oy2 = dwread_epd(origin);
    oy2 = f_dwread_epd(origin)
    # (Line 295) const tx, ty = (tx1+tx2), (ty1+ty2);
    tx, ty = List2Assignable([(tx1 + tx2), (ty1 + ty2)])
    # (Line 296) const ox, oy = (ox1+ox2), (oy1+oy2);
    ox, oy = List2Assignable([(ox1 + ox2), (oy1 + oy2)])
    # (Line 297) const dx, dy = tx-ox, ty-oy;
    dx, dy = List2Assignable([tx - ox, ty - oy])
    # (Line 298) const theta = atan2(dy, dx);
    theta = f_atan2(dy, dx)
    # (Line 299) const x, y = lengthdir(sqrt(dx*dx+dy*dy)/2, theta+angle);
    x, y = List2Assignable([f_lengthdir(f_sqrt(dx * dx + dy * dy) // 2, theta + angle)])
    # (Line 300) const rx, ry = x-dx, y-dy;
    rx, ry = List2Assignable([x - dx, y - dy])
    # (Line 301) dwadd_epd(target, ry);
    f_dwadd_epd(target, ry)
    # (Line 302) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 303) dwadd_epd(target, rx);
    f_dwadd_epd(target, rx)
    # (Line 304) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 305) dwadd_epd(target, ry);
    f_dwadd_epd(target, ry)
    # (Line 306) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 307) dwadd_epd(target, rx);
    f_dwadd_epd(target, rx)
    # (Line 308) }
    # (Line 322) function RemoveStatusFlagsEPD(epd, flags) {

@EUDFunc
def RemoveStatusFlagsEPD(epd, flags):
    # (Line 323) epd += 0xDC / 4;
    epd.__iadd__(0xDC // 4)
    # (Line 324) SetMemoryXEPD(epd, SetTo, 0, flags);
    # (Line 325) }
    DoActions(SetMemoryXEPD(epd, SetTo, 0, flags))
    # (Line 339) function RemoveStatusFlags(unitPTR, flags) {

@EUDFunc
def RemoveStatusFlags(unitPTR, flags):
    # (Line 340) RemoveStatusFlagsEPD(EPD(unitPTR), flags);
    RemoveStatusFlagsEPD(EPD(unitPTR), flags)
    # (Line 341) }
    # (Line 355) function SetPColor(Player: TrgPlayer, Color) {

@EUDTypedFunc([TrgPlayer, None])
def SetPColor(Player, Color):
    # (Line 356) DoActions(Player.AddNumber(0x581DD6));
    DoActions(Player.AddNumber(0x581DD6))
    # (Line 357) bwrite(Player, Color);
    f_bwrite(Player, Color)
    # (Line 361) VProc(Player, list(
    # (Line 362) Player.AddNumber(0x1FA7D16C),
    # (Line 363) Player.QueueAddTo(Player),
    # (Line 364) ));
    VProc(Player, FlattenList([Player.AddNumber(0x1FA7D16C), Player.QueueAddTo(Player)]))
    # (Line 365) bwrite_epd(Player, 2, Color);
    f_bwrite_epd(Player, 2, Color)
    # (Line 366) }
    # (Line 368) function __SpawnBase(epd, unit: TrgUnit, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit, TrgUnit])
def __SpawnBase(epd, unit, newUnit):
    # (Line 369) if (
    _t1 = EUDIf()
    # (Line 370) MemoryXEPD(epd + 0x64/4, Exactly, unit, 0xFFFF)
    # (Line 371) && MemoryXEPD(epd + 0x4E/4, Exactly, 0, 0xFF0000)
    # (Line 372) ) {
    if _t1(EUDSCAnd()(MemoryXEPD(epd + 0x64 // 4, Exactly, unit, 0xFFFF))(MemoryXEPD(epd + 0x4E // 4, Exactly, 0, 0xFF0000))()):
        # (Line 373) SetMemoryXEPD(epd + 0x4D/4, SetTo, (42 << 8) + (1 << 16), 0xFFFF00);
        # (Line 374) SetMemoryXEPD(epd + 0x98/4, SetTo, newUnit, 0xFFFF);
        DoActions(SetMemoryXEPD(epd + 0x4D // 4, SetTo, (_LSH(42,8)) + (_LSH(1,16)), 0xFFFF00))
        # (Line 375) }
        DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, newUnit, 0xFFFF))
        # (Line 376) }
    EUDEndIf()
    # (Line 390) function SpawnCocoonEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnCocoonEPD(epd, newUnit):
    # (Line 391) __SpawnBase(epd, 59, newUnit);
    __SpawnBase(epd, 59, newUnit)
    # (Line 392) }
    # (Line 406) function SpawnCocoon(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnCocoon(unitPTR, newUnit):
    # (Line 407) __SpawnBase(EPD(unitPTR), 59, newUnit);
    __SpawnBase(EPD(unitPTR), 59, newUnit)
    # (Line 408) }
    # (Line 422) function SpawnEggEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnEggEPD(epd, newUnit):
    # (Line 423) __SpawnBase(epd, 36, newUnit);
    __SpawnBase(epd, 36, newUnit)
    # (Line 424) }
    # (Line 438) function SpawnEgg(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnEgg(unitPTR, newUnit):
    # (Line 439) __SpawnBase(EPD(unitPTR), 36, newUnit);
    __SpawnBase(EPD(unitPTR), 36, newUnit)
    # (Line 440) }
    # (Line 454) function MorphLarvaEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def MorphLarvaEPD(epd, newUnit):
    # (Line 455) if (MemoryXEPD(epd + 0x64/4, Exactly, 35, 0xFFFF)) {
    if EUDIf()(MemoryXEPD(epd + 0x64 // 4, Exactly, 35, 0xFFFF)):
        # (Line 456) SetMemoryXEPD(epd + 0x4D/4, SetTo, 42 << 8, 0xFFFF00);
        # (Line 457) SetMemoryXEPD(epd + 0x98/4, SetTo, newUnit, 0xFFFF);
        DoActions(SetMemoryXEPD(epd + 0x4D // 4, SetTo, _LSH(42,8), 0xFFFF00))
        # (Line 458) }
        DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, newUnit, 0xFFFF))
        # (Line 459) }
    EUDEndIf()
    # (Line 473) function MorphLarva(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def MorphLarva(unitPTR, newUnit):
    # (Line 474) MorphLarvaEPD(EPD(unitPTR), newUnit);
    MorphLarvaEPD(EPD(unitPTR), newUnit)
    # (Line 475) }
    # (Line 489) function TrainUnitEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def TrainUnitEPD(epd, newUnit):
    # (Line 490) const nU_and_lsh16 = newUnit * 65537;
    nU_and_lsh16 = newUnit * 65537
    # (Line 491) VProc(epd, list(
    # (Line 492) epd.AddNumber(0x98/4),
    # (Line 493) epd.SetDest(EPD(0x6509B0)),
    # (Line 494) ));
    VProc(epd, FlattenList([epd.AddNumber(0x98 // 4), epd.SetDest(EPD(0x6509B0))]))
    # (Line 495) DoActions(list(
    # (Line 496) SetDeaths(CurrentPlayer, SetTo, nU_and_lsh16, 0),
    # (Line 497) SetMemory(0x6509B0, Add, 1),
    # (Line 498) SetDeaths(CurrentPlayer, SetTo, nU_and_lsh16, 0),
    # (Line 499) SetMemory(0x6509B0, Add, 1),
    # (Line 500) SetDeathsX(CurrentPlayer, SetTo, newUnit, 0, 0xFFFF),
    # (Line 501) SetMemory(0x6509B0, Add, 1),
    # (Line 502) SetDeathsX(CurrentPlayer, SetTo, 38 << 16, 0, 0xFF0000),
    # (Line 503) ));
    DoActions(FlattenList([SetDeaths(CurrentPlayer, SetTo, nU_and_lsh16, 0), SetMemory(0x6509B0, Add, 1), SetDeaths(CurrentPlayer, SetTo, nU_and_lsh16, 0), SetMemory(0x6509B0, Add, 1), SetDeathsX(CurrentPlayer, SetTo, newUnit, 0, 0xFFFF), SetMemory(0x6509B0, Add, 1), SetDeathsX(CurrentPlayer, SetTo, _LSH(38,16), 0, 0xFF0000)]))
    # (Line 504) setcurpl2cpcache();
    f_setcurpl2cpcache()
    # (Line 505) }
    # (Line 519) function TrainUnit(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def TrainUnit(unitPTR, newUnit):
    # (Line 520) TrainUnitEPD(EPD(unitPTR), newUnit);
    TrainUnitEPD(EPD(unitPTR), newUnit)
    # (Line 521) }
    # (Line 535) function SetUnitColorEPD(epd, color) {

@EUDFunc
def SetUnitColorEPD(epd, color):
    # (Line 536) epd += 0x0C/4;
    epd.__iadd__(0x0C // 4)
    # (Line 537) const sprite = epdread_epd(epd);
    sprite = f_epdread_epd(epd)
    # (Line 538) DoActions(sprite.AddNumber(0x0A/4));
    DoActions(sprite.AddNumber(0x0A // 4))
    # (Line 539) SetMemoryXEPD(sprite, SetTo, color * 65536, 0xFF0000);
    # (Line 540) }
    DoActions(SetMemoryXEPD(sprite, SetTo, color * 65536, 0xFF0000))
    # (Line 554) function SetUnitColor(unitPTR, color) {

@EUDFunc
def SetUnitColor(unitPTR, color):
    # (Line 555) SetUnitColorEPD(EPD(unitPTR), color);
    SetUnitColorEPD(EPD(unitPTR), color)
    # (Line 556) }
    # (Line 576) function SetLocationToUnitEPD(location: TrgLocation, unitEPD, CUnitOffsetX, CUnitOffsetY) {

@EUDTypedFunc([TrgLocation, None, None, None])
def SetLocationToUnitEPD(location, unitEPD, CUnitOffsetX, CUnitOffsetY):
    # (Line 577) if (CUnitOffsetX == CUnitOffsetY) {
    if EUDIf()(CUnitOffsetX == CUnitOffsetY):
        # (Line 578) unitEPD += CUnitOffsetX/4;
        unitEPD.__iadd__(CUnitOffsetX // 4)
        # (Line 579) setloc_epd(location, unitEPD);
        f_setloc_epd(location, unitEPD)
        # (Line 580) } else {
    if EUDElse()():
        # (Line 581) const x = wread_epd(unitEPD + CUnitOffsetX/4, 0);
        x = f_wread_epd(unitEPD + CUnitOffsetX // 4, 0)
        # (Line 582) const y = wread_epd(unitEPD + CUnitOffsetY/4, 2);
        y = f_wread_epd(unitEPD + CUnitOffsetY // 4, 2)
        # (Line 583) setloc(location, x, y);
        f_setloc(location, x, y)
        # (Line 584) }
        # (Line 585) }
    EUDEndIf()
    # (Line 605) function SetLocationToUnit(location: TrgLocation, unitPTR, CUnitOffsetX, CUnitOffsetY) {

@EUDTypedFunc([TrgLocation, None, None, None])
def SetLocationToUnit(location, unitPTR, CUnitOffsetX, CUnitOffsetY):
    # (Line 606) SetLocationToUnitEPD(location, EPD(unitPTR), CUnitOffsetX, CUnitOffsetY);
    SetLocationToUnitEPD(location, EPD(unitPTR), CUnitOffsetX, CUnitOffsetY)
    # (Line 607) }
    # (Line 630) function SetLocation(location: TrgLocation, X, Y, width, height) {

@EUDTypedFunc([TrgLocation, None, None, None, None])
def SetLocation(location, X, Y, width, height):
    # (Line 631) setloc(location, X, Y);
    f_setloc(location, X, Y)
    # (Line 632) dilateloc(location, width/2, height/2);
    f_dilateloc(location, width // 2, height // 2)
    # (Line 633) }
    # (Line 650) function EUDMoveLocation(Location: TrgLocation, X, Y) {

@EUDTypedFunc([TrgLocation, None, None])
def EUDMoveLocation(Location, X, Y):
    # (Line 651) addloc(Location, X, Y);
    f_addloc(Location, X, Y)
    # (Line 652) }
    # (Line 656) function ScreenShake(x, y, tempLoc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def ScreenShake(x, y, tempLoc):
    # (Line 658) const randX, randY = rand(), rand();
    randX, randY = List2Assignable([f_rand(), f_rand()])
    # (Line 659) if (IsUserCP()) {
    if EUDIf()(IsUserCP()):
        # (Line 660) const SCREEN_X, SCREEN_Y = 0x628448, 0x628470;
        SCREEN_X, SCREEN_Y = List2Assignable([0x628448, 0x628470])
        # (Line 661) const rX, rY = (randX % x) - x/2, (randY % y) - y/2;
        rX, rY = List2Assignable([(randX % x) - x // 2, (randY % y) - y // 2])
        # (Line 662) const screenX = dwread(SCREEN_X);
        screenX = f_dwread(SCREEN_X)
        # (Line 663) const screenY = dwread(SCREEN_Y);
        screenY = f_dwread(SCREEN_Y)
        # (Line 664) VProc(list(rX, rY), list(
        # (Line 665) rX.QueueAddTo(screenX),
        # (Line 666) rY.QueueAddTo(screenY)
        # (Line 667) ));
        VProc(FlattenList([rX, rY]), FlattenList([rX.QueueAddTo(screenX), rY.QueueAddTo(screenY)]))
        # (Line 668) setloc(tempLoc, screenX, screenY);
        f_setloc(tempLoc, screenX, screenY)
        # (Line 669) CenterView(64);
        # (Line 670) py_exec("chkt = GetChkTokenized()");
        DoActions(CenterView(64))
        exec("chkt = GetChkTokenized()")
        # (Line 671) py_exec("dim = chkt.getsection('DIM')");
        exec("dim = chkt.getsection('DIM')")
        # (Line 672) const mapX = py_eval("b2i2(dim) << 4");
        mapX = eval("b2i2(dim) << 4")
        # (Line 673) const mapY = py_eval("b2i2(dim, 2) << 4");
        mapY = eval("b2i2(dim, 2) << 4")
        # (Line 674) addloc(tempLoc, mapX - dwread(SCREEN_X), dwread(SCREEN_Y) - mapY);
        f_addloc(tempLoc, mapX - f_dwread(SCREEN_X), f_dwread(SCREEN_Y) - mapY)
        # (Line 675) CenterView(tempLoc);
        # (Line 676) }
        DoActions(CenterView(tempLoc))
        # (Line 677) }
    EUDEndIf()
    # (Line 697) function hotkeyUnitEPD(epd, player: TrgPlayer, hotkey, slot) {

@EUDTypedFunc([None, TrgPlayer, None, None])
def f_hotkeyUnitEPD(epd, player, hotkey, slot):
    # (Line 698) epd += 0xA5 / 4;
    epd.__iadd__(0xA5 // 4)
    # (Line 699) const targetOrderSpecial = maskread_epd(epd, 0xFF00);
    targetOrderSpecial = f_maskread_epd(epd, 0xFF00)
    # (Line 700) const alphaID = targetOrderSpecial * 8;
    alphaID = targetOrderSpecial * 8
    # (Line 701) DoActions(alphaID.AddNumber(1));
    DoActions(alphaID.AddNumber(1))
    # (Line 702) if (epd != 19025 + 0xA5 / 4) {
    if EUDIf()(epd == 19025 + 0xA5 // 4, neg=True):
        # (Line 703) epd += 1700 - 0x27821 - 0xA5 / 4;  // diff
        epd.__iadd__(1700 - 0x27821 - 0xA5 // 4)
        # (Line 704) VProc(epd, epd.QueueAddTo(alphaID));
        VProc(epd, epd.QueueAddTo(alphaID))
        # (Line 705) }
        # (Line 706) SetMemoryEPD(EPD(0x57FE60) + 216 * player + 12 * hotkey + slot, SetTo, alphaID);
    EUDEndIf()
    # (Line 707) }
    DoActions(SetMemoryEPD(EPD(0x57FE60) + 216 * player + 12 * hotkey + slot, SetTo, alphaID))
    # (Line 727) function hotkeyUnit(unitPTR, player: TrgPlayer, hotkey, slot) {

@EUDTypedFunc([None, TrgPlayer, None, None])
def f_hotkeyUnit(unitPTR, player, hotkey, slot):
    # (Line 728) hotkeyUnitEPD(EPD(unitPTR), player, hotkey, slot);
    f_hotkeyUnitEPD(EPD(unitPTR), player, hotkey, slot)
    # (Line 729) }
    # (Line 731) function __GetLocCoord(loc: TrgLocation) {

@EUDTypedFunc([TrgLocation])
def __GetLocCoord(loc):
    # (Line 732) const loc_epd = loc * 5;
    loc_epd = loc * 5
    # (Line 733) DoActions(loc_epd.AddNumber(EPD(0x58DC4C)));
    DoActions(loc_epd.AddNumber(EPD(0x58DC4C)))
    # (Line 734) const x1 = dwread_epd(loc_epd);
    x1 = f_dwread_epd(loc_epd)
    # (Line 735) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 736) const y1 = dwread_epd(loc_epd);
    y1 = f_dwread_epd(loc_epd)
    # (Line 737) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 738) const x2 = dwread_epd(loc_epd);
    x2 = f_dwread_epd(loc_epd)
    # (Line 739) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 740) const y2 = dwread_epd(loc_epd);
    y2 = f_dwread_epd(loc_epd)
    # (Line 741) return x1, y1, x2, y2;
    EUDReturn(x1, y1, x2, y2)
    # (Line 742) }
    # (Line 756) function LocationAngle(originLoc: TrgLocation, destLoc: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def LocationAngle(originLoc, destLoc):
    # (Line 757) const ox1, ox2, oy1, oy2 = __GetLocCoord(originLoc);
    ox1, ox2, oy1, oy2 = List2Assignable([__GetLocCoord(originLoc)])
    # (Line 758) const dx1, dx2, dy1, dy2 = __GetLocCoord(destLoc);
    dx1, dx2, dy1, dy2 = List2Assignable([__GetLocCoord(destLoc)])
    # (Line 759) const x1 = ox1 + ox2;
    x1 = ox1 + ox2
    # (Line 760) const y1 = oy1 + oy2;
    y1 = oy1 + oy2
    # (Line 761) const x2 = dx1 + dx2;
    x2 = dx1 + dx2
    # (Line 762) const y2 = dy1 + dy2;
    y2 = dy1 + dy2
    # (Line 763) return atan2(x2 - x1, y1 - y2);
    EUDReturn(f_atan2(x2 - x1, y1 - y2))
    # (Line 764) }
    # (Line 767) function GetAngle(originLoc: TrgLocation, destLoc: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def GetAngle(originLoc, destLoc):
    # (Line 768) return LocationAngle(originLoc, destLoc);
    EUDReturn(LocationAngle(originLoc, destLoc))
    # (Line 769) }
    # (Line 783) function LocationDistance(loc1: TrgLocation, loc2: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def LocationDistance(loc1, loc2):
    # (Line 784) const ox1, ox2, oy1, oy2 = __GetLocCoord(loc1);
    ox1, ox2, oy1, oy2 = List2Assignable([__GetLocCoord(loc1)])
    # (Line 785) const dx1, dx2, dy1, dy2 = __GetLocCoord(loc2);
    dx1, dx2, dy1, dy2 = List2Assignable([__GetLocCoord(loc2)])
    # (Line 786) const x = dx1 + dx2 - (ox1 + ox2);
    x = dx1 + dx2 - (ox1 + ox2)
    # (Line 787) const y = dy1 + dy2 - (oy1 + oy2);
    y = dy1 + dy2 - (oy1 + oy2)
    # (Line 788) return sqrt(x*x + y*y) / 2;
    EUDReturn(f_sqrt(x * x + y * y) // 2)
    # (Line 789) }
    # (Line 792) function LocationDistanceVal(variable, loc1: TrgLocation, loc2: TrgLocation) {

@EUDTypedFunc([None, TrgLocation, TrgLocation])
def LocationDistanceVal(variable, loc1, loc2):
    # (Line 793) return LocationDistance(loc1, loc2);
    EUDReturn(LocationDistance(loc1, loc2))
    # (Line 794) }
    # (Line 811) function PolarLocation(loc: TrgLocation, length, angle) {

@EUDTypedFunc([TrgLocation, None, None])
def PolarLocation(loc, length, angle):
    # (Line 812) const x, y = lengthdir(length, angle);
    x, y = List2Assignable([f_lengthdir(length, angle)])
    # (Line 813) addloc(loc, x, y);
    f_addloc(loc, x, y)
    # (Line 814) }
    # (Line 837) function CheckNoneTargetSkillEPD(

# (Line 838) unitEPD,
# (Line 839) range,
# (Line 840) unitLoc: TrgLocation,
# (Line 841) targetLoc: TrgLocation,
# (Line 842) skillOrder /*Order*/
# (Line 843) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckNoneTargetSkillEPD(unitEPD, range, unitLoc, targetLoc, skillOrder):
    # (Line 844) unitEPD += 0x4D/4;
    unitEPD.__iadd__(0x4D // 4)
    # (Line 845) if (MemoryXEPD(unitEPD, Exactly, skillOrder * 256, 0xFF00)) {
    if EUDIf()(MemoryXEPD(unitEPD, Exactly, skillOrder * 256, 0xFF00)):
        # (Line 846) unitEPD += -((0x4D - 0x28)/4);
        unitEPD.__iadd__(-((0x4D - 0x28) // 4))
        # (Line 847) const x, y = posread_epd(unitEPD);
        x, y = List2Assignable([f_posread_epd(unitEPD)])
        # (Line 848) setloc(unitLoc, x, y);
        f_setloc(unitLoc, x, y)
        # (Line 849) unitEPD += (0x58 - 0x28)/4;
        unitEPD.__iadd__((0x58 - 0x28) // 4)
        # (Line 850) setloc_epd(targetLoc, unitEPD);
        f_setloc_epd(targetLoc, unitEPD)
        # (Line 852) if (range > LocationDistance(unitLoc, targetLoc)) {
        if EUDIf()(range <= LocationDistance(unitLoc, targetLoc), neg=True):
            # (Line 853) MoveLocation(targetLoc, 227, AllPlayers, targetLoc);
            # (Line 854) unitEPD += -((0x58 - 0x4C)/4);
            DoActions(MoveLocation(targetLoc, 227, AllPlayers, targetLoc))
            unitEPD.__iadd__(-((0x58 - 0x4C) // 4))
            # (Line 855) SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00);
            # (Line 856) unitEPD += -((0x4D - 0x10)/4);
            DoActions(SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00))
            unitEPD.__iadd__(-((0x4D - 0x10) // 4))
            # (Line 857) SetMemoryEPD(unitEPD, SetTo, x + y * 65536);
            # (Line 858) return True;
            DoActions(SetMemoryEPD(unitEPD, SetTo, x + y * 65536))
            EUDReturn(True)
            # (Line 859) }
            # (Line 860) }
        EUDEndIf()
        # (Line 861) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 862) }
    # (Line 885) function CheckNoneTargetSkill(

# (Line 886) unitPTR,
# (Line 887) range,
# (Line 888) unitLoc: TrgLocation,
# (Line 889) targetLoc: TrgLocation,
# (Line 890) skillOrder /*Order*/
# (Line 891) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckNoneTargetSkill(unitPTR, range, unitLoc, targetLoc, skillOrder):
    # (Line 892) return CheckNoneTargetSkillEPD(
    # (Line 893) EPD(unitPTR),
    # (Line 894) range,
    # (Line 895) unitLoc,
    # (Line 896) targetLoc,
    # (Line 897) skillOrder /*Order*/
    # (Line 898) );
    EUDReturn(CheckNoneTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder))
    # (Line 899) }
    # (Line 918) function SetLocationToUnitSafeEPD(location: TrgLocation, unitEPD, posX) {

@EUDTypedFunc([TrgLocation, None, None])
def SetLocationToUnitSafeEPD(location, unitEPD, posX):
    # (Line 919) unitEPD += posX/4;
    unitEPD.__iadd__(posX // 4)
    # (Line 920) setloc_epd(location, unitEPD);
    f_setloc_epd(location, unitEPD)
    # (Line 921) }
    # (Line 939) function SetLocationToUnitSafe(location: TrgLocation, unitPTR, posX) {

@EUDTypedFunc([TrgLocation, None, None])
def SetLocationToUnitSafe(location, unitPTR, posX):
    # (Line 940) SetLocationToUnitSafeEPD(location, EPD(unitPTR), posX);
    SetLocationToUnitSafeEPD(location, EPD(unitPTR), posX)
    # (Line 941) }
    # (Line 964) function CheckTargetSkillEPD(

# (Line 965) unitEPD,
# (Line 966) range,
# (Line 967) unitLoc: TrgLocation,
# (Line 968) targetLoc: TrgLocation,
# (Line 969) skillOrder
# (Line 970) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckTargetSkillEPD(unitEPD, range, unitLoc, targetLoc, skillOrder):
    # (Line 971) if (MemoryXEPD(unitEPD + 0x4D/4, Exactly, skillOrder * 256, 0xFF00)) {
    if EUDIf()(MemoryXEPD(unitEPD + 0x4D // 4, Exactly, skillOrder * 256, 0xFF00)):
        # (Line 972) const x, y = posread_epd(unitEPD + 0x28/4);
        x, y = List2Assignable([f_posread_epd(unitEPD + 0x28 // 4)])
        # (Line 973) setloc(unitLoc, x, y);
        f_setloc(unitLoc, x, y)
        # (Line 974) setloc_epd(targetLoc, unitEPD + 0x58/4);
        f_setloc_epd(targetLoc, unitEPD + 0x58 // 4)
        # (Line 975) if (range > LocationDistance(unitLoc, targetLoc)) {
        if EUDIf()(range <= LocationDistance(unitLoc, targetLoc), neg=True):
            # (Line 976) MoveLocation(targetLoc, 227, 17, targetLoc);
            # (Line 977) SetMemoryXEPD(unitEPD + 0x4D/4, SetTo, 0x100, 0xFF00);
            DoActions(MoveLocation(targetLoc, 227, 17, targetLoc))
            # (Line 978) SetMemoryEPD(unitEPD + 0x10/4, SetTo, x + y * 65536);
            DoActions(SetMemoryXEPD(unitEPD + 0x4D // 4, SetTo, 0x100, 0xFF00))
            # (Line 979) return True;
            DoActions(SetMemoryEPD(unitEPD + 0x10 // 4, SetTo, x + y * 65536))
            EUDReturn(True)
            # (Line 980) }
            # (Line 981) }
        EUDEndIf()
        # (Line 982) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 983) }
    # (Line 1006) function CheckTargetSkill(

# (Line 1007) unitPTR,
# (Line 1008) range,
# (Line 1009) unitLoc: TrgLocation,
# (Line 1010) targetLoc: TrgLocation,
# (Line 1011) skillOrder
# (Line 1012) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckTargetSkill(unitPTR, range, unitLoc, targetLoc, skillOrder):
    # (Line 1013) return CheckTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder);
    EUDReturn(CheckTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder))
    # (Line 1014) }
    # (Line 1031) function CBringEPD(unitEPD, location: TrgLocation, dummyUnit: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def CBringEPD(unitEPD, location, dummyUnit):
    # (Line 1032) MoveLocation(location, dummyUnit, AllPlayers, location);
    # (Line 1033) const unitType = unitEPD + 0x64/4;
    DoActions(MoveLocation(location, dummyUnit, AllPlayers, location))
    unitType = unitEPD + 0x64 // 4
    # (Line 1034) const originalUnitType = wread_epd(unitType, 0);
    originalUnitType = f_wread_epd(unitType, 0)
    # (Line 1035) SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF);
    # (Line 1036) const ret = l2v(Bring(AllPlayers, AtLeast, 1, dummyUnit, location));
    DoActions(SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF))
    ret = _L2V(Bring(AllPlayers, AtLeast, 1, dummyUnit, location))
    # (Line 1037) SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF);
    # (Line 1038) return ret;
    DoActions(SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF))
    EUDReturn(ret)
    # (Line 1039) }
    # (Line 1056) function CBring(unitPTR, location: TrgLocation, dummyUnit: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def CBring(unitPTR, location, dummyUnit):
    # (Line 1057) return CBringEPD(EPD(unitPTR), location, dummyUnit);
    EUDReturn(CBringEPD(EPD(unitPTR), location, dummyUnit))
    # (Line 1058) }
    # (Line 1069) function BuildResetEPD(unitEPD) {

@EUDFunc
def BuildResetEPD(unitEPD):
    # (Line 1070) VProc(unitEPD, list(
    # (Line 1071) unitEPD.AddNumber(0x98/4),
    # (Line 1072) unitEPD.SetDest(EPD(0x6509B0)),
    # (Line 1073) ));
    VProc(unitEPD, FlattenList([unitEPD.AddNumber(0x98 // 4), unitEPD.SetDest(EPD(0x6509B0))]))
    # (Line 1074) setcurpl2cpcache(actions=list(
    # (Line 1075) SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0),
    # (Line 1076) SetMemory(0x6509B0, Add, 1),
    # (Line 1077) SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0),
    # (Line 1078) SetMemory(0x6509B0, Add, 1),
    # (Line 1079) SetDeathsX(CurrentPlayer, SetTo, 228, 0, 0xFFFF),
    # (Line 1080) SetMemory(0x6509B0, Add, 1),
    # (Line 1081) SetDeathsX(CurrentPlayer, SetTo, 2 << 16, 0, 0xFFFF0000),
    # (Line 1082) ));
    f_setcurpl2cpcache(actions=FlattenList([SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0), SetMemory(0x6509B0, Add, 1), SetDeaths(CurrentPlayer, SetTo, 0xE400E4, 0), SetMemory(0x6509B0, Add, 1), SetDeathsX(CurrentPlayer, SetTo, 228, 0, 0xFFFF), SetMemory(0x6509B0, Add, 1), SetDeathsX(CurrentPlayer, SetTo, _LSH(2,16), 0, 0xFFFF0000)]))
    # (Line 1083) }
    # (Line 1094) function BuildReset(unitPTR) {

@EUDFunc
def BuildReset(unitPTR):
    # (Line 1095) BuildResetEPD(EPD(unitPTR));
    BuildResetEPD(EPD(unitPTR))
    # (Line 1096) }
    # (Line 1110) function BuildCheckEPD(unitEPD, unit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def BuildCheckEPD(unitEPD, unit):
    # (Line 1111) unitEPD += 0x98 / 4;  // buildQueue
    unitEPD.__iadd__(0x98 // 4)
    # (Line 1112) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
    if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
        # (Line 1113) return True;
        EUDReturn(True)
        # (Line 1114) } else {
    if EUDElse()():
        # (Line 1115) const mulUnit = unit * 65536;
        mulUnit = unit * 65536
        # (Line 1116) if (MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)) {
        if EUDIf()(MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)):
            # (Line 1117) return True;
            EUDReturn(True)
            # (Line 1118) } else {
        if EUDElse()():
            # (Line 1119) unitEPD += 1;
            unitEPD.__iadd__(1)
            # (Line 1120) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
            if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
                # (Line 1121) return True;
                EUDReturn(True)
                # (Line 1122) } else if (MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)) {
            if EUDElseIf()(MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)):
                # (Line 1123) return True;
                EUDReturn(True)
                # (Line 1124) } else {
            if EUDElse()():
                # (Line 1125) unitEPD += 1;
                unitEPD.__iadd__(1)
                # (Line 1126) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
                if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
                    # (Line 1127) return True;
                    EUDReturn(True)
                    # (Line 1128) }
                    # (Line 1129) }
                EUDEndIf()
                # (Line 1130) }
            EUDEndIf()
            # (Line 1131) }
        EUDEndIf()
        # (Line 1132) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 1133) }
    # (Line 1147) function BuildCheck(unitPTR, unit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def BuildCheck(unitPTR, unit):
    # (Line 1148) return BuildCheckEPD(EPD(unitPTR), unit);
    EUDReturn(BuildCheckEPD(EPD(unitPTR), unit))
    # (Line 1149) }
    # (Line 1172) function AttackGround(

# (Line 1173) attackLoc: TrgLocation,
# (Line 1174) targetLoc: TrgLocation,
# (Line 1175) attackUnit: TrgUnit,
# (Line 1176) targetUnit: TrgUnit,
# (Line 1177) player: TrgPlayer
# (Line 1178) ) {
@EUDTypedFunc([TrgLocation, TrgLocation, TrgUnit, TrgUnit, TrgPlayer])
def AttackGround(attackLoc, targetLoc, attackUnit, targetUnit, player):
    # (Line 1179) if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    if EUDIf()(Memory(0x628438, Exactly, 0)):
        EUDReturn()
        # (Line 1180) const aUnit = cunitepdread_epd(EPD(0x628438))[[1]];
    EUDEndIf()
    aUnit = f_cunitepdread_epd(EPD(0x628438))[1]
    # (Line 1181) CreateUnit(1, attackUnit, attackLoc, player);
    # (Line 1182) DoActions(aUnit.AddNumber(0x110 / 4));
    DoActions(CreateUnit(1, attackUnit, attackLoc, player))
    DoActions(aUnit.AddNumber(0x110 // 4))
    # (Line 1183) SetMemoryEPD(aUnit, Add, 2);  // aUnit + 0x110 (CUnit::removeTimer)
    # (Line 1185) if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    DoActions(SetMemoryEPD(aUnit, Add, 2))
    if EUDIf()(Memory(0x628438, Exactly, 0)):
        EUDReturn()
        # (Line 1186) const tunitptr, tunit = cunitepdread_epd(EPD(0x628438));
    EUDEndIf()
    tunitptr, tunit = List2Assignable([f_cunitepdread_epd(EPD(0x628438))])
    # (Line 1187) CreateUnit(1, targetUnit, targetLoc, player);
    # (Line 1188) DoActions(list(
    DoActions(CreateUnit(1, targetUnit, targetLoc, player))
    # (Line 1189) tunit.AddNumber(0x110 / 4),
    # (Line 1190) aUnit.AddNumber(-((0x110 - 0x5C) / 4))
    # (Line 1191) ));
    DoActions(FlattenList([tunit.AddNumber(0x110 // 4), aUnit.AddNumber(-((0x110 - 0x5C) // 4))]))
    # (Line 1192) SetMemoryEPD(aUnit, SetTo, tunitptr);  // aUnit + 0x5C (CUnit::targetUnit)
    # (Line 1193) SetMemoryEPD(tunit, Add, 2);  // tunit + 0x110 (CUnit::removeTimer)
    DoActions(SetMemoryEPD(aUnit, SetTo, tunitptr))
    # (Line 1195) DoActions(aUnit.AddNumber(-((0x5C - 0x4C) / 4)));
    DoActions(SetMemoryEPD(tunit, Add, 2))
    DoActions(aUnit.AddNumber(-((0x5C - 0x4C) // 4)))
    # (Line 1196) SetMemoryXEPD(aUnit, SetTo, 0xA00, 0xFF00);  // order[10]=attack, 0x4D (CUnit::order)
    # (Line 1197) }
    DoActions(SetMemoryXEPD(aUnit, SetTo, 0xA00, 0xFF00))
    # (Line 1211) function AddStatusFlagsEPD(epd, flags) {

@EUDFunc
def AddStatusFlagsEPD(epd, flags):
    # (Line 1212) epd += 0xDC / 4;
    epd.__iadd__(0xDC // 4)
    # (Line 1213) SetMemoryXEPD(epd, SetTo, ~0, flags);
    # (Line 1214) }
    DoActions(SetMemoryXEPD(epd, SetTo, ~0, flags))
    # (Line 1228) function AddStatusFlags(unitPTR, flags) {

@EUDFunc
def AddStatusFlags(unitPTR, flags):
    # (Line 1229) unitPTR += 0xDC;
    unitPTR.__iadd__(0xDC)
    # (Line 1230) SetMemoryX(unitPTR, SetTo, ~0, flags);
    # (Line 1231) }
    DoActions(SetMemoryX(unitPTR, SetTo, ~0, flags))
    # (Line 1248) function AddSizeLocation(location: TrgLocation, width, height) {

@EUDTypedFunc([TrgLocation, None, None])
def AddSizeLocation(location, width, height):
    # (Line 1249) dilateloc(location, width, height);
    f_dilateloc(location, width, height)
    # (Line 1250) }
