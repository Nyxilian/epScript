## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY
from eudplib import *

def _IGVA(vList, exprListGen):
    def _():
        exprList = exprListGen()
        SetVariables(vList, exprList)
    EUDOnStart(_)

def _CGFW(exprf, retn):
    rets = [ExprProxy(None) for _ in range(retn)]
    def _():
        vals = exprf()
        for ret, val in zip(rets, vals):
            ret._value = val
    EUDOnStart(_)
    return rets

def _ARR(items):
    k = EUDArray(len(items))
    for i, item in enumerate(items):
        k[i] = item
    return k

def _VARR(items):
    k = EUDVArray(len(items))()
    for i, item in enumerate(items):
        k[i] = item
    return k

def _SRET(v, klist):
    return List2Assignable([v[k] for k in klist])

def _SV(dL, sL):
    [d << s for d, s in zip(FlattenList(dL), FlattenList(sL))]

class _ATTW:
    def __init__(self, obj, attrName):
        self.obj = obj
        self.attrName = attrName

    def __lshift__(self, r):
        setattr(self.obj, self.attrName, r)

    def __iadd__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov + v)

    def __isub__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov - v)

    def __imul__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov * v)

    def __ifloordiv__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov // v)

    def __iand__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov & v)

    def __ior__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov | v)

    def __ixor__(self, v):
        ov = getattr(self.obj, self.attrName)
        setattr(self.obj, self.attrName, ov ^ v)

class _ARRW:
    def __init__(self, obj, index):
        self.obj = obj
        self.index = index

    def __lshift__(self, r):
        self.obj[self.index] = r

    def __iadd__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov + v

    def __isub__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov - v

    def __imul__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov * v

    def __ifloordiv__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov // v

    def __iand__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov & v

    def __ior__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov | v

    def __ixor__(self, v):
        ov = self.obj[self.index]
        self.obj[self.index] = ov ^ v

def _L2V(l):
    ret = EUDVariable()
    if EUDIf()(l):
        ret << 1
    if EUDElse()():
        ret << 0
    EUDEndIf()
    return ret

def _MVAR(vs):
    return List2Assignable([
        v.makeL() if IsEUDVariable(v) else EUDVariable() << v
        for v in FlattenList(vs)])

def _LSH(l, r):
    if IsEUDVariable(l):  return f_bitlshift(l, r)
    else: return l << r

## NOTE: THIS FILE IS GENERATED BY EPSCRIPT! DO NOT MODITY

# (Line 16) function CountAtLoc(player: TrgPlayer, unit: TrgUnit, loc: TrgLocation) {
@EUDTypedFunc([TrgPlayer, TrgUnit, TrgLocation])
def CountAtLoc(player, unit, loc):
    # (Line 18) var x = 0xFF;
    x = EUDVariable()
    x << (0xFF)
    # (Line 19) foreach(i : py_range(31, -1, -1)) {
    for i in range(31, -1, -1):
        # (Line 20) if (x >= py_pow(2, i)) {
        if EUDIf()(x >= pow(2, i)):
            # (Line 21) x -= py_pow(2, i);
            x.__isub__(pow(2, i))
            # (Line 22) if (!Bring(player, AtMost, x, unit, loc)) {
            if EUDIf()(Bring(player, AtMost, x, unit, loc), neg=True):
                # (Line 23) x += py_pow(2, i);
                x.__iadd__(pow(2, i))
                # (Line 24) }
                # (Line 25) }
            EUDEndIf()
            # (Line 26) }
        EUDEndIf()
        # (Line 27) return x;

    EUDReturn(x)
    # (Line 28) }
    # (Line 30) function __LocOrderBase(

# (Line 31) epd,
# (Line 32) order_lsh8,
# (Line 33) loc: TrgLocation
# (Line 34) ) {
@EUDTypedFunc([None, None, TrgLocation])
def __LocOrderBase(epd, order_lsh8, loc):
    # (Line 35) const loc_epd = loc * 5;
    loc_epd = loc * 5
    # (Line 36) DoActions(loc_epd.AddNumber(EPD(0x58DC4C)));
    DoActions(loc_epd.AddNumber(EPD(0x58DC4C)))
    # (Line 38) const x1 = dwread_epd(loc_epd);
    x1 = f_dwread_epd(loc_epd)
    # (Line 39) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 40) const y1 = dwread_epd(loc_epd);
    y1 = f_dwread_epd(loc_epd)
    # (Line 41) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 42) const x2 = dwread_epd(loc_epd);
    x2 = f_dwread_epd(loc_epd)
    # (Line 43) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 44) const y2 = dwread_epd(loc_epd);
    y2 = f_dwread_epd(loc_epd)
    # (Line 46) const x = (x1 + x2) / 2;
    x = (x1 + x2) // 2
    # (Line 47) const y = (y1 + y2) << 15;  // = (y1 + y2) / 2 * 65536
    y = _LSH((y1 + y2),15)
    # (Line 49) epd += 0x4D / 4;
    epd.__iadd__(0x4D // 4)
    # (Line 50) SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00);
    # (Line 51) epd += (0x58 - 0x4D) / 4;
    DoActions(SetMemoryXEPD(epd, SetTo, order_lsh8, 0xFF00))
    epd.__iadd__((0x58 - 0x4D) // 4)
    # (Line 52) SetMemoryEPD(epd, SetTo, y + x);
    # (Line 53) }
    DoActions(SetMemoryEPD(epd, SetTo, y + x))
    # (Line 55) function BuildProbeEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildProbeEPD(epd, loc, building):
    # (Line 56) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 57) __LocOrderBase(epd, 31 << 8, loc);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(31,8), loc)
    # (Line 58) }
    # (Line 60) function BuildProbe(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildProbe(unitPTR, loc, building):
    # (Line 61) BuildProbeEPD(EPD(unitPTR), loc, building);
    BuildProbeEPD(EPD(unitPTR), loc, building)
    # (Line 62) }
    # (Line 64) function BuildDroneEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildDroneEPD(epd, loc, building):
    # (Line 65) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 66) __LocOrderBase(epd, 25 << 8, loc, building);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(25,8), loc, building)
    # (Line 67) }
    # (Line 69) function BuildDrone(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildDrone(unitPTR, loc, building):
    # (Line 70) BuildDroneEPD(EPD(unitPTR), loc, building);
    BuildDroneEPD(EPD(unitPTR), loc, building)
    # (Line 71) }
    # (Line 73) function BuildSCVEPD(epd, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildSCVEPD(epd, loc, building):
    # (Line 74) SetMemoryXEPD(epd + 0x98 / 4, SetTo, building, 0xFFFF);
    # (Line 75) __LocOrderBase(epd, 30 << 8, loc, building);
    DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, building, 0xFFFF))
    __LocOrderBase(epd, _LSH(30,8), loc, building)
    # (Line 76) }
    # (Line 78) function BuildSCV(unitPTR, loc: TrgLocation, building: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def BuildSCV(unitPTR, loc, building):
    # (Line 79) BuildSCVEPD(EPD(unitPTR), loc, building);
    BuildSCVEPD(EPD(unitPTR), loc, building)
    # (Line 80) }
    # (Line 82) function COrderLocEPD(epd, order, loc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def COrderLocEPD(epd, order, loc):
    # (Line 83) __LocOrderBase(epd, order << 8, loc);
    __LocOrderBase(epd, _LSH(order,8), loc)
    # (Line 84) }
    # (Line 86) function COrderLoc(unitPTR, order, loc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def COrderLoc(unitPTR, order, loc):
    # (Line 87) __LocOrderBase(EPD(unitPTR), order << 8, loc);
    __LocOrderBase(EPD(unitPTR), _LSH(order,8), loc)
    # (Line 88) }
    # (Line 90) function COrderUnitEPD(unitEPD, order, targetPTR) {

@EUDFunc
def COrderUnitEPD(unitEPD, order, targetPTR):
    # (Line 91) bwrite_epd(unitEPD + 0x04D / 4,  0x04D % 4, order);
    f_bwrite_epd(unitEPD + 0x04D // 4, 0x04D % 4, order)
    # (Line 92) SetMemoryEPD(unitEPD + 0x05C / 4, SetTo, targetPTR);
    # (Line 93) }
    DoActions(SetMemoryEPD(unitEPD + 0x05C // 4, SetTo, targetPTR))
    # (Line 95) function COrderUnit(unitPTR, order, targetPTR) {

@EUDFunc
def COrderUnit(unitPTR, order, targetPTR):
    # (Line 96) bwrite(unitPTR + 0x04D, order);
    f_bwrite(unitPTR + 0x04D, order)
    # (Line 97) dwwrite(unitPTR + 0x05C, targetPTR);
    f_dwwrite(unitPTR + 0x05C, targetPTR)
    # (Line 98) }
    # (Line 100) function RotateLocation(targetLoc: TrgLocation, originLoc: TrgLocation, angle) {

@EUDTypedFunc([TrgLocation, TrgLocation, None])
def RotateLocation(targetLoc, originLoc, angle):
    # (Line 101) const locTable = EPD(0x58DC4C);
    locTable = EPD(0x58DC4C)
    # (Line 102) const target = targetLoc * 5;
    target = targetLoc * 5
    # (Line 103) const origin = originLoc * 5;
    origin = originLoc * 5
    # (Line 104) DoActions(list(
    # (Line 105) target.AddNumber(locTable),
    # (Line 106) origin.AddNumber(locTable)
    # (Line 107) ));
    DoActions(FlattenList([target.AddNumber(locTable), origin.AddNumber(locTable)]))
    # (Line 109) const tx1 = dwread_epd(target);
    tx1 = f_dwread_epd(target)
    # (Line 110) const ox1 = dwread_epd(origin);
    ox1 = f_dwread_epd(origin)
    # (Line 111) DoActions(list(
    # (Line 112) target.AddNumber(1),
    # (Line 113) origin.AddNumber(1)
    # (Line 114) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 115) const ty1 = dwread_epd(target);
    ty1 = f_dwread_epd(target)
    # (Line 116) const oy1 = dwread_epd(origin);
    oy1 = f_dwread_epd(origin)
    # (Line 117) DoActions(list(
    # (Line 118) target.AddNumber(1),
    # (Line 119) origin.AddNumber(1)
    # (Line 120) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 121) const tx2 = dwread_epd(target);
    tx2 = f_dwread_epd(target)
    # (Line 122) const ox2 = dwread_epd(origin);
    ox2 = f_dwread_epd(origin)
    # (Line 123) DoActions(list(
    # (Line 124) target.AddNumber(1),
    # (Line 125) origin.AddNumber(1)
    # (Line 126) ));
    DoActions(FlattenList([target.AddNumber(1), origin.AddNumber(1)]))
    # (Line 127) const ty2 = dwread_epd(target);
    ty2 = f_dwread_epd(target)
    # (Line 128) const oy2 = dwread_epd(origin);
    oy2 = f_dwread_epd(origin)
    # (Line 130) const tx, ty = (tx1+tx2)/2, (ty1+ty2)/2;
    tx, ty = List2Assignable([(tx1 + tx2) // 2, (ty1 + ty2) // 2])
    # (Line 131) const ox, oy = (ox1+ox2)/2, (oy1+oy2)/2;
    ox, oy = List2Assignable([(ox1 + ox2) // 2, (oy1 + oy2) // 2])
    # (Line 132) const dx, dy = tx-ox, ty-oy;
    dx, dy = List2Assignable([tx - ox, ty - oy])
    # (Line 133) const theta = atan2(dy, dx);
    theta = f_atan2(dy, dx)
    # (Line 134) const x, y = lengthdir(sqrt(dx*dx+dy*dy), theta+angle);
    x, y = List2Assignable([f_lengthdir(f_sqrt(dx * dx + dy * dy), theta + angle)])
    # (Line 135) const rx, ry = x-dx, y-dy;
    rx, ry = List2Assignable([x - dx, y - dy])
    # (Line 136) dwadd_epd(target, ry);
    f_dwadd_epd(target, ry)
    # (Line 137) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 138) dwadd_epd(target, rx);
    f_dwadd_epd(target, rx)
    # (Line 139) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 140) dwadd_epd(target, ry);
    f_dwadd_epd(target, ry)
    # (Line 141) DoActions(target.AddNumber(-1));
    DoActions(target.AddNumber(-1))
    # (Line 142) dwadd_epd(target, rx);
    f_dwadd_epd(target, rx)
    # (Line 143) }
    # (Line 145) function RemoveStatusFlagsEPD(epd, flags) {

@EUDFunc
def RemoveStatusFlagsEPD(epd, flags):
    # (Line 146) epd += 0xDC / 4;
    epd.__iadd__(0xDC // 4)
    # (Line 147) DoActions(SetMemoryXEPD(epd, SetTo, 0, flags));
    DoActions(SetMemoryXEPD(epd, SetTo, 0, flags))
    # (Line 148) }
    # (Line 150) function RemoveStatusFlags(unitPTR, flags) {

@EUDFunc
def RemoveStatusFlags(unitPTR, flags):
    # (Line 151) dwsubtract_epd(EPD(unitPTR) + 0xDC / 4, flags & dwread_epd(EPD(unitPTR) + 0xDC / 4));
    f_dwsubtract_epd(EPD(unitPTR) + 0xDC // 4, flags & f_dwread_epd(EPD(unitPTR) + 0xDC // 4))
    # (Line 152) }
    # (Line 154) function SetPColor(pnum, color) {

@EUDFunc
def SetPColor(pnum, color):
    # (Line 155) const pcolor_dst = 0x581D76 + 8 * pnum;
    pcolor_dst = 0x581D76 + 8 * pnum
    # (Line 156) const mcolor_dst = 0x581DD6 + pnum;
    mcolor_dst = 0x581DD6 + pnum
    # (Line 157) bwrite(pcolor_dst, color);
    f_bwrite(pcolor_dst, color)
    # (Line 158) bwrite(mcolor_dst, color);
    f_bwrite(mcolor_dst, color)
    # (Line 159) }
    # (Line 161) function __SpawnBase(epd, unit: TrgUnit, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit, TrgUnit])
def __SpawnBase(epd, unit, newUnit):
    # (Line 162) if (
    _t1 = EUDIf()
    # (Line 163) MemoryXEPD(epd + 0x64/4, Exactly, unit, 0xFFFF)
    # (Line 164) && MemoryXEPD(epd + 0x4E/4, Exactly, 0, 0xFF0000)
    # (Line 165) ) {
    if _t1(EUDSCAnd()(MemoryXEPD(epd + 0x64 // 4, Exactly, unit, 0xFFFF))(MemoryXEPD(epd + 0x4E // 4, Exactly, 0, 0xFF0000))()):
        # (Line 166) SetMemoryXEPD(epd + 0x4D/4, SetTo, (42 << 8) + (1 << 16), 0xFFFF00);
        # (Line 167) SetMemoryXEPD(epd + 0x98/4, SetTo, newUnit, 0xFFFF);
        DoActions(SetMemoryXEPD(epd + 0x4D // 4, SetTo, (_LSH(42,8)) + (_LSH(1,16)), 0xFFFF00))
        # (Line 168) }
        DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, newUnit, 0xFFFF))
        # (Line 169) }
    EUDEndIf()
    # (Line 171) function SpawnCocoonEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnCocoonEPD(epd, newUnit):
    # (Line 172) __SpawnBase(epd, 59, newUnit);
    __SpawnBase(epd, 59, newUnit)
    # (Line 173) }
    # (Line 175) function SpawnCocoon(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnCocoon(unitPTR, newUnit):
    # (Line 176) __SpawnBase(EPD(unitPTR), 59, newUnit);
    __SpawnBase(EPD(unitPTR), 59, newUnit)
    # (Line 177) }
    # (Line 179) function SpawnEggEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnEggEPD(epd, newUnit):
    # (Line 180) __SpawnBase(epd, 36, newUnit);
    __SpawnBase(epd, 36, newUnit)
    # (Line 181) }
    # (Line 183) function SpawnEgg(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def SpawnEgg(unitPTR, newUnit):
    # (Line 184) __SpawnBase(EPD(unitPTR), 36, newUnit);
    __SpawnBase(EPD(unitPTR), 36, newUnit)
    # (Line 185) }
    # (Line 187) function MorphLarvaEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def MorphLarvaEPD(epd, newUnit):
    # (Line 188) if (MemoryXEPD(epd + 0x64/4, Exactly, newUnit, 0xFFFF)) {
    if EUDIf()(MemoryXEPD(epd + 0x64 // 4, Exactly, newUnit, 0xFFFF)):
        # (Line 189) SetMemoryXEPD(epd + 0x4D/4, SetTo, 42 << 8, 0xFFFF00);
        # (Line 190) SetMemoryXEPD(epd + 0x98/4, SetTo, newUnit, 0xFFFF);
        DoActions(SetMemoryXEPD(epd + 0x4D // 4, SetTo, _LSH(42,8), 0xFFFF00))
        # (Line 191) }
        DoActions(SetMemoryXEPD(epd + 0x98 // 4, SetTo, newUnit, 0xFFFF))
        # (Line 192) }
    EUDEndIf()
    # (Line 194) function TrainUnitEPD(epd, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def TrainUnitEPD(epd, newUnit):
    # (Line 195) const nU_and_lsh16 = newUnit * 65537;
    nU_and_lsh16 = newUnit * 65537
    # (Line 196) epd += 0x98/4;
    epd.__iadd__(0x98 // 4)
    # (Line 197) SetMemoryEPD(epd, SetTo, nU_and_lsh16);
    # (Line 198) epd += 1;
    DoActions(SetMemoryEPD(epd, SetTo, nU_and_lsh16))
    epd.__iadd__(1)
    # (Line 199) SetMemoryEPD(epd, SetTo, nU_and_lsh16);
    # (Line 200) epd += 1;
    DoActions(SetMemoryEPD(epd, SetTo, nU_and_lsh16))
    epd.__iadd__(1)
    # (Line 201) SetMemoryXEPD(epd, SetTo, newUnit, 0xFFFF);
    # (Line 202) epd += 1;
    DoActions(SetMemoryXEPD(epd, SetTo, newUnit, 0xFFFF))
    epd.__iadd__(1)
    # (Line 203) SetMemoryXEPD(epd, SetTo, 38 << 16, 0xFF0000);
    # (Line 204) }
    DoActions(SetMemoryXEPD(epd, SetTo, _LSH(38,16), 0xFF0000))
    # (Line 206) function TrainUnit(unitPTR, newUnit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def TrainUnit(unitPTR, newUnit):
    # (Line 207) TrainUnitEPD(EPD(unitPTR), newUnit);
    TrainUnitEPD(EPD(unitPTR), newUnit)
    # (Line 208) }
    # (Line 210) function SetUnitColorEPD(epd, color) {

@EUDFunc
def SetUnitColorEPD(epd, color):
    # (Line 211) epd += 0x0C/4;
    epd.__iadd__(0x0C // 4)
    # (Line 212) const sprite = epdread_epd(epd);
    sprite = f_epdread_epd(epd)
    # (Line 213) DoActions(sprite.AddNumber(0x0A/4));
    DoActions(sprite.AddNumber(0x0A // 4))
    # (Line 214) SetMemoryEPD(sprite, SetTo, color * 65536, 0xFF0000);
    # (Line 215) }
    DoActions(SetMemoryEPD(sprite, SetTo, color * 65536, 0xFF0000))
    # (Line 217) function SetUnitColor(unitPTR, color) {

@EUDFunc
def SetUnitColor(unitPTR, color):
    # (Line 218) SetUnitColorEPD(EPD(unitPTR), color);
    SetUnitColorEPD(EPD(unitPTR), color)
    # (Line 219) }
    # (Line 221) function SetLocationToUnitEPD(location: TrgLocation, unitEPD, CUnitOffsetX, CUnitOffsetY) {

@EUDTypedFunc([TrgLocation, None, None, None])
def SetLocationToUnitEPD(location, unitEPD, CUnitOffsetX, CUnitOffsetY):
    # (Line 222) if (CUnitOffsetX == CUnitOffsetY) {
    if EUDIf()(CUnitOffsetX == CUnitOffsetY):
        # (Line 223) unitEPD += CUnitOffsetX/4;
        unitEPD.__iadd__(CUnitOffsetX // 4)
        # (Line 224) setloc_epd(location, unitEPD);
        f_setloc_epd(location, unitEPD)
        # (Line 225) } else {
    if EUDElse()():
        # (Line 226) const x = wread_epd(unitEPD + CUnitOffsetX/4, 0);
        x = f_wread_epd(unitEPD + CUnitOffsetX // 4, 0)
        # (Line 227) const y = wread_epd(unitEPD + CUnitOffsetY/4, 2);
        y = f_wread_epd(unitEPD + CUnitOffsetY // 4, 2)
        # (Line 228) setloc(location, x, y);
        f_setloc(location, x, y)
        # (Line 229) }
        # (Line 230) }
    EUDEndIf()
    # (Line 232) function SetLocationToUnit(location: TrgLocation, unitPTR, CUnitOffsetX, CUnitOffsetY) {

@EUDTypedFunc([TrgLocation, None, None, None])
def SetLocationToUnit(location, unitPTR, CUnitOffsetX, CUnitOffsetY):
    # (Line 233) SetLocationToUnitEPD(location, EPD(unitPTR), CUnitOffsetX, CUnitOffsetY);
    SetLocationToUnitEPD(location, EPD(unitPTR), CUnitOffsetX, CUnitOffsetY)
    # (Line 234) }
    # (Line 236) function SetLocation(location: TrgLocation, X, Y, width, height) {

@EUDTypedFunc([TrgLocation, None, None, None, None])
def SetLocation(location, X, Y, width, height):
    # (Line 237) setloc(location, X, Y);
    f_setloc(location, X, Y)
    # (Line 238) dilateloc(location, width/2, height/2);
    f_dilateloc(location, width // 2, height // 2)
    # (Line 239) }
    # (Line 241) function EUDMoveLocation(Location: TrgLocation, X, Y) {

@EUDTypedFunc([TrgLocation, None, None])
def EUDMoveLocation(Location, X, Y):
    # (Line 242) addloc(Location, X, Y);
    f_addloc(Location, X, Y)
    # (Line 243) }
    # (Line 247) function ScreenShake(x, y, tempLoc: TrgLocation) {

@EUDTypedFunc([None, None, TrgLocation])
def ScreenShake(x, y, tempLoc):
    # (Line 249) const randX, randY = rand(), rand();
    randX, randY = List2Assignable([f_rand(), f_rand()])
    # (Line 250) if (IsUserCP()) {
    if EUDIf()(IsUserCP()):
        # (Line 251) const SCREEN_X, SCREEN_Y = 0x628448, 0x628470;
        SCREEN_X, SCREEN_Y = List2Assignable([0x628448, 0x628470])
        # (Line 252) const rX, rY = (randX % x) - x/2, (randY % y) - y/2;
        rX, rY = List2Assignable([(randX % x) - x // 2, (randY % y) - y // 2])
        # (Line 253) const screenX = dwread(SCREEN_X);
        screenX = f_dwread(SCREEN_X)
        # (Line 254) const screenY = dwread(SCREEN_Y);
        screenY = f_dwread(SCREEN_Y)
        # (Line 255) VProc(list(rX, rY), list(
        # (Line 256) rX.QueueAddTo(screenX),
        # (Line 257) rY.QueueAddTo(screenY)
        # (Line 258) ));
        VProc(FlattenList([rX, rY]), FlattenList([rX.QueueAddTo(screenX), rY.QueueAddTo(screenY)]))
        # (Line 259) setloc(tempLoc, screenX, screenY);
        f_setloc(tempLoc, screenX, screenY)
        # (Line 260) CenterView(64);
        # (Line 261) py_exec("chkt = GetChkTokenized()");
        DoActions(CenterView(64))
        exec("chkt = GetChkTokenized()")
        # (Line 262) py_exec("dim = chkt.getsection('DIM')");
        exec("dim = chkt.getsection('DIM')")
        # (Line 263) const mapX = py_eval("b2i2(dim) << 4");
        mapX = eval("b2i2(dim) << 4")
        # (Line 264) const mapY = py_eval("b2i2(dim, 2) << 4");
        mapY = eval("b2i2(dim, 2) << 4")
        # (Line 265) addloc(tempLoc, mapX - dwread(SCREEN_X), dwread(SCREEN_Y) - mapY);
        f_addloc(tempLoc, mapX - f_dwread(SCREEN_X), f_dwread(SCREEN_Y) - mapY)
        # (Line 266) CenterView(tempLoc);
        # (Line 267) }
        DoActions(CenterView(tempLoc))
        # (Line 268) }
    EUDEndIf()
    # (Line 270) function hotkeyUnitEPD(epd, player: TrgPlayer, hotkey, slot) {

@EUDTypedFunc([None, TrgPlayer, None, None])
def f_hotkeyUnitEPD(epd, player, hotkey, slot):
    # (Line 271) epd += 0xA5 / 4;
    epd.__iadd__(0xA5 // 4)
    # (Line 272) const targetOrderSpecial = maskread_epd(epd, 0xFF00);
    targetOrderSpecial = f_maskread_epd(epd, 0xFF00)
    # (Line 273) const alphaID = targetOrderSpecial * 8;
    alphaID = targetOrderSpecial * 8
    # (Line 274) DoActions(alphaID.AddNumber(1));
    DoActions(alphaID.AddNumber(1))
    # (Line 275) if (epd != 19025 + 0xA5 / 4) {
    if EUDIf()(epd == 19025 + 0xA5 // 4, neg=True):
        # (Line 276) epd += 1700 - 0x27821 - 0xA5 / 4;  // diff
        epd.__iadd__(1700 - 0x27821 - 0xA5 // 4)
        # (Line 277) VProc(epd, epd.QueueAddTo(alphaID));
        VProc(epd, epd.QueueAddTo(alphaID))
        # (Line 278) }
        # (Line 279) SetMemoryEPD(EPD(0x57FE60) + 216 * player + 12 * hotkey + slot, SetTo, alphaID);
    EUDEndIf()
    # (Line 280) }
    DoActions(SetMemoryEPD(EPD(0x57FE60) + 216 * player + 12 * hotkey + slot, SetTo, alphaID))
    # (Line 282) function hotkeyUnit(unitPTR, player: TrgPlayer, hotkey, slot) {

@EUDTypedFunc([None, TrgPlayer, None, None])
def f_hotkeyUnit(unitPTR, player, hotkey, slot):
    # (Line 283) hotkeyUnitEPD(EPD(unitPTR), player, hotkey, slot);
    f_hotkeyUnitEPD(EPD(unitPTR), player, hotkey, slot)
    # (Line 284) }
    # (Line 286) function __GetLocCoord(loc: TrgLocation) {

@EUDTypedFunc([TrgLocation])
def __GetLocCoord(loc):
    # (Line 287) const loc_epd = loc * 5;
    loc_epd = loc * 5
    # (Line 288) DoActions(loc_epd.AddNumber(EPD(0x58DC4C)));
    DoActions(loc_epd.AddNumber(EPD(0x58DC4C)))
    # (Line 289) const x1 = dwread_epd(loc_epd);
    x1 = f_dwread_epd(loc_epd)
    # (Line 290) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 291) const y1 = dwread_epd(loc_epd);
    y1 = f_dwread_epd(loc_epd)
    # (Line 292) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 293) const x2 = dwread_epd(loc_epd);
    x2 = f_dwread_epd(loc_epd)
    # (Line 294) DoActions(loc_epd.AddNumber(1));
    DoActions(loc_epd.AddNumber(1))
    # (Line 295) const y2 = dwread_epd(loc_epd);
    y2 = f_dwread_epd(loc_epd)
    # (Line 296) return x1, y1, x2, y2;
    EUDReturn(x1, y1, x2, y2)
    # (Line 297) }
    # (Line 299) function LocationAngle(originLoc: TrgLocation, destLoc: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def LocationAngle(originLoc, destLoc):
    # (Line 300) const ox1, ox2, oy1, oy2 = __GetLocCoord(originLoc);
    ox1, ox2, oy1, oy2 = List2Assignable([__GetLocCoord(originLoc)])
    # (Line 301) const dx1, dx2, dy1, dy2 = __GetLocCoord(destLoc);
    dx1, dx2, dy1, dy2 = List2Assignable([__GetLocCoord(destLoc)])
    # (Line 302) const x1 = (ox1 + ox2) / 2;
    x1 = (ox1 + ox2) // 2
    # (Line 303) const y1 = (oy1 + oy2) / 2;
    y1 = (oy1 + oy2) // 2
    # (Line 304) const x2 = (dx1 + dx2) / 2;
    x2 = (dx1 + dx2) // 2
    # (Line 305) const y2 = (dy1 + dy2) / 2;
    y2 = (dy1 + dy2) // 2
    # (Line 306) return atan2(x2 - x1, y1 - y2);
    EUDReturn(f_atan2(x2 - x1, y1 - y2))
    # (Line 307) }
    # (Line 310) function GetAngle(originLoc: TrgLocation, destLoc: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def GetAngle(originLoc, destLoc):
    # (Line 311) return LocationAngle(originLoc, destLoc);
    EUDReturn(LocationAngle(originLoc, destLoc))
    # (Line 312) }
    # (Line 314) function LocationDistance(loc1: TrgLocation, loc2: TrgLocation) {

@EUDTypedFunc([TrgLocation, TrgLocation])
def LocationDistance(loc1, loc2):
    # (Line 315) const ox1, ox2, oy1, oy2 = __GetLocCoord(loc1);
    ox1, ox2, oy1, oy2 = List2Assignable([__GetLocCoord(loc1)])
    # (Line 316) const dx1, dx2, dy1, dy2 = __GetLocCoord(loc2);
    dx1, dx2, dy1, dy2 = List2Assignable([__GetLocCoord(loc2)])
    # (Line 317) const x = dx1 + dx2 - (ox1 + ox2);
    x = dx1 + dx2 - (ox1 + ox2)
    # (Line 318) const y = dy1 + dy2 - (oy1 + oy2);
    y = dy1 + dy2 - (oy1 + oy2)
    # (Line 319) return sqrt(x*x + y*y) / 2;
    EUDReturn(f_sqrt(x * x + y * y) // 2)
    # (Line 320) }
    # (Line 323) function LocationDistanceVal(variable, loc1: TrgLocation, loc2: TrgLocation) {

@EUDTypedFunc([None, TrgLocation, TrgLocation])
def LocationDistanceVal(variable, loc1, loc2):
    # (Line 324) return LocationDistance(loc1, loc2);
    EUDReturn(LocationDistance(loc1, loc2))
    # (Line 325) }
    # (Line 327) function PolarLocation(loc: TrgLocation, length, angle) {

@EUDTypedFunc([TrgLocation, None, None])
def PolarLocation(loc, length, angle):
    # (Line 328) const x, y = lengthdir(length, angle);
    x, y = List2Assignable([f_lengthdir(length, angle)])
    # (Line 329) setloc(loc, x, y);
    f_setloc(loc, x, y)
    # (Line 330) }
    # (Line 332) function CheckNoneTargetSkillEPD(

# (Line 333) unitEPD,
# (Line 334) range,
# (Line 335) unitLoc: TrgLocation,
# (Line 336) targetLoc: TrgLocation,
# (Line 337) skillOrder /*Order*/
# (Line 338) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckNoneTargetSkillEPD(unitEPD, range, unitLoc, targetLoc, skillOrder):
    # (Line 339) unitEPD += 0x4D/4;
    unitEPD.__iadd__(0x4D // 4)
    # (Line 340) if (MemoryXEPD(unitEPD, Exactly, skillOrder * 256, 0xFF00)) {
    if EUDIf()(MemoryXEPD(unitEPD, Exactly, skillOrder * 256, 0xFF00)):
        # (Line 341) unitEPD += -((0x4D - 0x28)/4);
        unitEPD.__iadd__(-((0x4D - 0x28) // 4))
        # (Line 342) const x, y = posread_epd(unitEPD);
        x, y = List2Assignable([f_posread_epd(unitEPD)])
        # (Line 343) setloc(unitLoc, x, y);
        f_setloc(unitLoc, x, y)
        # (Line 344) unitEPD += (0x58 - 0x28)/4;
        unitEPD.__iadd__((0x58 - 0x28) // 4)
        # (Line 345) setloc_epd(targetLoc, unitEPD);
        f_setloc_epd(targetLoc, unitEPD)
        # (Line 347) if (range > LocationDistance(unitLoc, targetLoc)) {
        if EUDIf()(range <= LocationDistance(unitLoc, targetLoc), neg=True):
            # (Line 348) MoveLocation(targetLoc, 227, AllPlayers, targetLoc);
            # (Line 349) unitEPD += -((0x58 - 0x4D)/4);
            DoActions(MoveLocation(targetLoc, 227, AllPlayers, targetLoc))
            unitEPD.__iadd__(-((0x58 - 0x4D) // 4))
            # (Line 350) SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00);
            # (Line 351) unitEPD += -((0x4D - 0x10)/4);
            DoActions(SetMemoryXEPD(unitEPD, SetTo, 0x100, 0xFF00))
            unitEPD.__iadd__(-((0x4D - 0x10) // 4))
            # (Line 352) SetMemoryEPD(unitEPD, SetTo, x + y * 65536);
            # (Line 353) return True;
            DoActions(SetMemoryEPD(unitEPD, SetTo, x + y * 65536))
            EUDReturn(True)
            # (Line 354) }
            # (Line 355) }
        EUDEndIf()
        # (Line 356) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 357) }
    # (Line 359) function CheckNoneTargetSkill(

# (Line 360) unitPTR,
# (Line 361) range,
# (Line 362) unitLoc: TrgLocation,
# (Line 363) targetLoc: TrgLocation,
# (Line 364) skillOrder /*Order*/
# (Line 365) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckNoneTargetSkill(unitPTR, range, unitLoc, targetLoc, skillOrder):
    # (Line 366) return CheckNoneTargetSkillEPD(
    # (Line 367) EPD(unitPTR),
    # (Line 368) range,
    # (Line 369) unitLoc,
    # (Line 370) targetLoc,
    # (Line 371) skillOrder /*Order*/
    # (Line 372) );
    EUDReturn(CheckNoneTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder))
    # (Line 373) }
    # (Line 375) function SetLocationToUnitSafeEPD(location: TrgLocation, unitEPD, posX) {

@EUDTypedFunc([TrgLocation, None, None])
def SetLocationToUnitSafeEPD(location, unitEPD, posX):
    # (Line 376) unitEPD += posX/4;
    unitEPD.__iadd__(posX // 4)
    # (Line 377) setloc_epd(location, unitEPD);
    f_setloc_epd(location, unitEPD)
    # (Line 378) }
    # (Line 380) function SetLocationToUnitSafe(location: TrgLocation, unitPTR, posX) {

@EUDTypedFunc([TrgLocation, None, None])
def SetLocationToUnitSafe(location, unitPTR, posX):
    # (Line 381) SetLocationToUnitSafeEPD(location, EPD(unitPTR), posX);
    SetLocationToUnitSafeEPD(location, EPD(unitPTR), posX)
    # (Line 382) }
    # (Line 384) function CheckTargetSkillEPD(

# (Line 385) unitEPD,
# (Line 386) range,
# (Line 387) unitLoc: TrgLocation,
# (Line 388) targetLoc: TrgLocation,
# (Line 389) skillOrder
# (Line 390) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckTargetSkillEPD(unitEPD, range, unitLoc, targetLoc, skillOrder):
    # (Line 391) if (MemoryXEPD(unitEPD + 0x4D/4, Exactly, skillOrder * 256, 0xFF00)) {
    if EUDIf()(MemoryXEPD(unitEPD + 0x4D // 4, Exactly, skillOrder * 256, 0xFF00)):
        # (Line 392) const x, y = posread_epd(unitEPD + 0x28/4);
        x, y = List2Assignable([f_posread_epd(unitEPD + 0x28 // 4)])
        # (Line 393) setloc(unitLoc, x, y);
        f_setloc(unitLoc, x, y)
        # (Line 394) setloc_epd(targetLoc, unitEPD + 0x58/4);
        f_setloc_epd(targetLoc, unitEPD + 0x58 // 4)
        # (Line 395) if (range > LocationDistance(unitLoc, targetLoc)) {
        if EUDIf()(range <= LocationDistance(unitLoc, targetLoc), neg=True):
            # (Line 396) MoveLocation(targetLoc, 227, 17, targetLoc);
            # (Line 397) SetMemoryXEPD(unitEPD + 0x4D/4, SetTo, 0x100, 0xFF00);
            DoActions(MoveLocation(targetLoc, 227, 17, targetLoc))
            # (Line 398) SetMemoryEPD(unitEPD + 0x10/4, SetTo, x + y * 65536);
            DoActions(SetMemoryXEPD(unitEPD + 0x4D // 4, SetTo, 0x100, 0xFF00))
            # (Line 399) return True;
            DoActions(SetMemoryEPD(unitEPD + 0x10 // 4, SetTo, x + y * 65536))
            EUDReturn(True)
            # (Line 400) }
            # (Line 401) }
        EUDEndIf()
        # (Line 402) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 403) }
    # (Line 405) function CheckTargetSkill(

# (Line 406) unitPTR,
# (Line 407) range,
# (Line 408) unitLoc: TrgLocation,
# (Line 409) targetLoc: TrgLocation,
# (Line 410) skillOrder
# (Line 411) ) {
@EUDTypedFunc([None, None, TrgLocation, TrgLocation, None])
def CheckTargetSkill(unitPTR, range, unitLoc, targetLoc, skillOrder):
    # (Line 412) return CheckTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder);
    EUDReturn(CheckTargetSkillEPD(EPD(unitPTR), range, unitLoc, targetLoc, skillOrder))
    # (Line 413) }
    # (Line 415) function CBringEPD(unitEPD, location: TrgLocation, dummyUnit: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def CBringEPD(unitEPD, location, dummyUnit):
    # (Line 416) MoveLocation(location, dummyUnit, AllPlayers, location);
    # (Line 417) const unitType = unitEPD + 0x64/4;
    DoActions(MoveLocation(location, dummyUnit, AllPlayers, location))
    unitType = unitEPD + 0x64 // 4
    # (Line 418) const originalUnitType = wread_epd(unitType, 0);
    originalUnitType = f_wread_epd(unitType, 0)
    # (Line 419) SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF);
    # (Line 420) const ret = l2v(Bring(AllPlayers, AtLeast, 1, dummyUnit, location));
    DoActions(SetMemoryXEPD(unitType, SetTo, dummyUnit, 0xFFFF))
    ret = _L2V(Bring(AllPlayers, AtLeast, 1, dummyUnit, location))
    # (Line 421) SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF);
    # (Line 422) return ret;
    DoActions(SetMemoryXEPD(unitType, SetTo, originalUnitType, 0xFFFF))
    EUDReturn(ret)
    # (Line 423) }
    # (Line 425) function CBring(unitPTR, location: TrgLocation, dummyUnit: TrgUnit) {

@EUDTypedFunc([None, TrgLocation, TrgUnit])
def CBring(unitPTR, location, dummyUnit):
    # (Line 426) return CBringEPD(EPD(unitPTR, location, dummyUnit));
    EUDReturn(CBringEPD(EPD(unitPTR, location, dummyUnit)))
    # (Line 427) }
    # (Line 429) function BuildResetEPD(unitEPD) {

@EUDFunc
def BuildResetEPD(unitEPD):
    # (Line 430) unitEPD += 0x98/4;
    unitEPD.__iadd__(0x98 // 4)
    # (Line 431) SetMemoryEPD(unitEPD, SetTo, 0xE400E4);
    # (Line 432) unitEPD += 1;
    DoActions(SetMemoryEPD(unitEPD, SetTo, 0xE400E4))
    unitEPD.__iadd__(1)
    # (Line 433) SetMemoryEPD(unitEPD, SetTo, 0xE400E4);
    # (Line 434) unitEPD += 1;
    DoActions(SetMemoryEPD(unitEPD, SetTo, 0xE400E4))
    unitEPD.__iadd__(1)
    # (Line 435) SetMemoryXEPD(unitEPD, SetTo, 228, 0xFFFF);
    # (Line 436) unitEPD += 1;
    DoActions(SetMemoryXEPD(unitEPD, SetTo, 228, 0xFFFF))
    unitEPD.__iadd__(1)
    # (Line 437) SetMemoryXEPD(unitEPD, SetTo, 2 << 16, 0xFFFF0000);
    # (Line 438) }
    DoActions(SetMemoryXEPD(unitEPD, SetTo, _LSH(2,16), 0xFFFF0000))
    # (Line 440) function BuildReset(unitPTR) {

@EUDFunc
def BuildReset(unitPTR):
    # (Line 441) BuildResetEPD(EPD(unitPTR));
    BuildResetEPD(EPD(unitPTR))
    # (Line 442) }
    # (Line 444) function BuildCheckEPD(unitEPD, unit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def BuildCheckEPD(unitEPD, unit):
    # (Line 445) unitEPD += 0x98 / 4;  // buildQueue
    unitEPD.__iadd__(0x98 // 4)
    # (Line 446) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
    if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
        # (Line 447) return True;
        EUDReturn(True)
        # (Line 448) } else {
    if EUDElse()():
        # (Line 449) const mulUnit = unit * 65536;
        mulUnit = unit * 65536
        # (Line 450) if (MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)) {
        if EUDIf()(MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)):
            # (Line 451) return True;
            EUDReturn(True)
            # (Line 452) } else {
        if EUDElse()():
            # (Line 453) unitEPD += 1;
            unitEPD.__iadd__(1)
            # (Line 454) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
            if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
                # (Line 455) return True;
                EUDReturn(True)
                # (Line 456) } else if (MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)) {
            if EUDElseIf()(MemoryXEPD(unitEPD, Exactly, mulUnit, 0xFFFF0000)):
                # (Line 457) return True;
                EUDReturn(True)
                # (Line 458) } else {
            if EUDElse()():
                # (Line 459) unitEPD += 1;
                unitEPD.__iadd__(1)
                # (Line 460) if (MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)) {
                if EUDIf()(MemoryXEPD(unitEPD, Exactly, unit, 0xFFFF)):
                    # (Line 461) return True;
                    EUDReturn(True)
                    # (Line 462) }
                    # (Line 463) }
                EUDEndIf()
                # (Line 464) }
            EUDEndIf()
            # (Line 465) }
        EUDEndIf()
        # (Line 466) return False;
    EUDEndIf()
    EUDReturn(False)
    # (Line 467) }
    # (Line 469) function BuildCheck(unitPTR, unit: TrgUnit) {

@EUDTypedFunc([None, TrgUnit])
def BuildCheck(unitPTR, unit):
    # (Line 470) return BuildCheckEPD(EPD(unitPTR), unit);
    EUDReturn(BuildCheckEPD(EPD(unitPTR), unit))
    # (Line 471) }
    # (Line 473) function AttackGround(

# (Line 474) attackLoc: TrgLocation,
# (Line 475) targetLoc: TrgLocation,
# (Line 476) attackUnit: TrgUnit,
# (Line 477) targetUnit: TrgUnit,
# (Line 478) player: TrgPlayer
# (Line 479) ) {
@EUDTypedFunc([TrgLocation, TrgLocation, TrgUnit, TrgUnit, TrgPlayer])
def AttackGround(attackLoc, targetLoc, attackUnit, targetUnit, player):
    # (Line 480) if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    if EUDIf()(Memory(0x628438, Exactly, 0)):
        EUDReturn()
        # (Line 481) const aUnit = cunitepdread_epd(EPD(0x628438))[[1]];
    EUDEndIf()
    aUnit = f_cunitepdread_epd(EPD(0x628438))[1]
    # (Line 482) CreateUnit(1, attackUnit, attackLoc, player);
    # (Line 483) DoActions(aUnit.AddNumber(0x110 / 4));
    DoActions(CreateUnit(1, attackUnit, attackLoc, player))
    DoActions(aUnit.AddNumber(0x110 // 4))
    # (Line 484) SetMemoryEPD(aUnit, Add, 2);  // aUnit + 0x110 (CUnit::removeTimer)
    # (Line 486) if (Memory(0x628438, Exactly, 0)) return;  // avoid EUDError when CCMU
    DoActions(SetMemoryEPD(aUnit, Add, 2))
    if EUDIf()(Memory(0x628438, Exactly, 0)):
        EUDReturn()
        # (Line 487) const tunitptr, tunit = cunitepdread_epd(EPD(0x628438));
    EUDEndIf()
    tunitptr, tunit = List2Assignable([f_cunitepdread_epd(EPD(0x628438))])
    # (Line 488) CreateUnit(1, targetUnit, targetLoc, player);
    # (Line 489) DoActions(list(
    DoActions(CreateUnit(1, targetUnit, targetLoc, player))
    # (Line 490) tunit.AddNumber(0x110 / 4),
    # (Line 491) aUnit.AddNumber(-((0x110 - 0x5C) / 4))
    # (Line 492) ));
    DoActions(FlattenList([tunit.AddNumber(0x110 // 4), aUnit.AddNumber(-((0x110 - 0x5C) // 4))]))
    # (Line 493) SetMemoryEPD(aUnit, SetTo, tunitptr);  // aUnit + 0x5C (CUnit::targetUnit)
    # (Line 494) SetMemoryEPD(tunit, Add, 2);  // tunit + 0x110 (CUnit::removeTimer)
    DoActions(SetMemoryEPD(aUnit, SetTo, tunitptr))
    # (Line 496) DoActions(aUnit.AddNumber(-((0x5C - 0x4D) / 4)));
    DoActions(SetMemoryEPD(tunit, Add, 2))
    DoActions(aUnit.AddNumber(-((0x5C - 0x4D) // 4)))
    # (Line 497) SetMemoryXEPD(aUnit, 0xA00, 0xFF00);  // order[10]=attack, 0x4D (CUnit::order)
    # (Line 498) }
    DoActions(SetMemoryXEPD(aUnit, 0xA00, 0xFF00))
    # (Line 500) function AddStatusFlagsEPD(epd, flags) {

@EUDFunc
def AddStatusFlagsEPD(epd, flags):
    # (Line 501) epd += 0xDC / 4;
    epd.__iadd__(0xDC // 4)
    # (Line 502) SetMemoryXEPD(epd, SetTo, ~0, flags);
    # (Line 503) }
    DoActions(SetMemoryXEPD(epd, SetTo, ~0, flags))
    # (Line 505) function AddStatusFlags(unitPTR, flags) {

@EUDFunc
def AddStatusFlags(unitPTR, flags):
    # (Line 506) unitPTR += 0xDC;
    unitPTR.__iadd__(0xDC)
    # (Line 507) SetMemoryX(unitPTR, SetTo, ~0, flags);
    # (Line 508) }
    DoActions(SetMemoryX(unitPTR, SetTo, ~0, flags))
    # (Line 511) function AddSizeLocation(location: TrgLocation, width, height) {

@EUDTypedFunc([TrgLocation, None, None])
def AddSizeLocation(location, width, height):
    # (Line 512) dilateloc(location, width, height);
    f_dilateloc(location, width, height)
    # (Line 513) }
